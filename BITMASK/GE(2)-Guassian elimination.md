# VECTOR SPACE & GAUSSIAN ELIMINATION 

- Using the linearly independent vectors of Vector Space (GE (2) of 0's & 1's we reduce down the complexicity certain algo's)
- Eg to get the max_xor of a subset {We can't really compute the XOR of all subsets -> 2^N  expo complexicity so to reduce down we make a Basis Array of Linealy Independent Vectors to get MAX XOR}

- WHY DOES IT WORKS ?
- Because all subsets of an arrays does not generates unique XOR values & that is because it may be possible some element of array can itself be generated by taking the XOR of a set of element :
  ```
  Eg 6 ^ 1 = 7 and we also have 7  in array so taking one of these 2 is enough ! rather that generating all subsets with both!
  ```
  So to eliminate such cases we make out vector space= BASIS array {linearly independent values x of arr to mto make uniq xor values } -> Perform Gaussian Elimination : ROW ECHELON FORM OF MATRIX

# CONDITION TO KEEP IN MIND
- We are looking for pivot for all positions in basis array -> At max size = 64 BITS {Long long int nums }
```
- If any element x has ith position as set bit :
      // Case 1: New Pivot. : The i-th bit is set in x, and there's no existing generator.
    -  if B[i] == 0 :
              B[i] = x
              break; {to fix the generator for the ith position!}
        else :
              x = x^B[i]
              // since we already have a generator for ith bit so we toggled the ith position in x
              and check the rest of the position if it can become an independent generator for other position
- If ith position is not set :
      Simply its not independent so continue to check for other position if any set or not!
```

```cpp
onst ll MAX_BITS = 32;
vector<ll> make_basis(vector<ll>& a) {
    vector<ll> basis(MAX_BITS , 0) ;
    
    for (ll x : a) {
        
        for (ll i = MAX_BITS - 1 ; i >= 0 ; i--) {
            if (!((x >> i)&1)) {
                continue ;
            }
            if (basis[i] == 0) {
                basis[i] = x ;
                // Case 1: New Pivot.
                // The i-th bit is set in x, and there's no existing generator.
                break ;
            }else {
                // Case 2: Elimination (The Gaussian step).
                // Use the existing pivot basis[i] to eliminate the i-th bit in x.
                x ^= basis[i] ; 
            }
        }
    }
    return basis ;
}
```

